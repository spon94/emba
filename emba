#!/bin/bash -p
# see: https://developer.apple.com/library/archive/documentation/OpenSource/Conceptual/ShellScripting/ShellScriptSecurity/ShellScriptSecurity.html#//apple_ref/doc/uid/TP40004268-CH8-SW29

# EMBA - EMBEDDED LINUX ANALYZER
#
# Copyright 2020-2023 Siemens AG
# Copyright 2020-2024 Siemens Energy AG
#
# EMBA comes with ABSOLUTELY NO WARRANTY. This is free software, and you are
# welcome to redistribute it under the terms of the GNU General Public License.
# See LICENSE file for usage of this software.
#
# EMBA is licensed under GPLv3
# SPDX-License-Identifier: GPL-3.0-only
#
# Author(s): Michael Messner, Pascal Eckmann
# Contributor(s): Stefan Haboeck

# Description:  Main script for load all necessary files and call main function of modules

INVOCATION_PATH="."
MODULE_COUNT=0

# 导入 helpers 文件夹中前缀为 helpers_emba_ 的脚本文件
# 使用其中定义的函数和变量
import_helper()
{
  local HELPERS=()
  local HELPER_COUNT=0
  local HELPER_FILE=""
  # 读取由 find 生成的文件列表，并将文件名存储在 HELPERS 数组中
  # iname 指定了搜索的文件名模式，忽略大小写
  # -print0 使 find 命令输出的文件名以空字符（null character，'\0'）分隔，而不是默认的换行符
  # 2> /dev/null 将错误输出重定向到 /dev/null，这意味着任何错误信息（例如权限问题）都会被忽略
  # < <(...) 是一种进程替换，用于将括号中的命令输出作为输入传递给前面的命令
  # mapfile 用于将输入的每一行读取到一个数组中
  # -d '' 指定分隔符为空字符（null character，'\0'），与 find -print0 的输出格式匹配
  mapfile -d '' HELPERS < <(find "${HELP_DIR}" -iname "helpers_emba_*.sh" -print0 2> /dev/null)
  # @ 表示数组的所有元素
  for HELPER_FILE in "${HELPERS[@]}" ; do
    # ! [[ "${HELPER_FILE}" =~ \ |\' ]]：检查变量 HELPER_FILE 中是否包含空格或单引号字符
    # [[ ... ]] 是 bash 的条件测试命令，比 [ 和 test 更强大，支持更多的操作符和更复杂的表达式
    # =~ 是 bash 的正则表达式匹配运算符，用于检查字符串是否匹配指定的正则表达式模式
    if ( file "${HELPER_FILE}" | grep -q "shell script" ) && ! [[ "${HELPER_FILE}" =~ \ |\' ]] ; then
      # https://github.com/koalaman/shellcheck/wiki/SC1090
      # shellcheck source=/dev/null

      # source 命令用于在当前 shell 环境中读取并执行指定文件的内容
      # 与 ./ 不同，source 不会在子 shell 中执行脚本，而是在当前 shell 中执行，
      # 这意味着任何定义的函数、变量或修改的环境都会在当前 shell 有效
      # 在一些 shell（如 bash）中，source 命令也可以用 . 来代替
      source "${HELPER_FILE}"
      (( HELPER_COUNT+=1 ))
    fi
  done
  print_output "==> ""${GREEN}""Imported ""${HELPER_COUNT}"" helper files""${NC}" "no_log"
}

import_module()
{
  local MODULES=()
  local MODULES_LOCAL=()
  local MODULES_EMBA=()
  local MODULE_COUNT=0
  local MODULE_FILE=""
  # to ensure we are only auto load modules from the modules main directory we set maxdepth
  # with this in place we can create sub directories per module. For using/loading stuff from
  # these sub directories the modules are responsible!

  # maxdepth 1 的设置使得我们可以为每个模块创建子目录，对于使用/加载这些子目录中的内容，各模块需自行负责
  # sort -V: 按照版本号进行排序
  mapfile -t MODULES_EMBA < <(find "${MOD_DIR}" -maxdepth 1 -name "*.sh" | sort -V 2> /dev/null)
  # 读入 modules_local 文件夹中的模块信息
  if [[ -d "${MOD_DIR_LOCAL}" ]]; then
    mapfile -t MODULES_LOCAL < <(find "${MOD_DIR_LOCAL}" -maxdepth 1 -name "*.sh" 2>/dev/null | sort -V 2> /dev/null)
  fi
  # 数组拼接操作
  MODULES=( "${MODULES_EMBA[@]}" "${MODULES_LOCAL[@]}" )
  for MODULE_FILE in "${MODULES[@]}" ; do
    if ( file "${MODULE_FILE}" | grep -q "shell script" ) && ! [[ "${MODULE_FILE}" =~ \ |\' ]] ; then
      # https://github.com/koalaman/shellcheck/wiki/SC1090
      # shellcheck source=/dev/null

      # 读入模块文件
      source "${MODULE_FILE}"
      (( MODULE_COUNT+=1 ))
    fi
  done
  print_output "==> ""${GREEN}""Imported ""${MODULE_COUNT}"" module/s""${NC}" "no_log"
}

sort_modules()
{
  local SORTED_MODULES=()
  local MODULE_FILE=""
  for MODULE_FILE in "${MODULES[@]}" ; do
    if ( file "${MODULE_FILE}" | grep -q "shell script" ) && ! [[ "${MODULE_FILE}" =~ \ |\' ]] ; then
      THREAD_PRIO=0
      # https://github.com/koalaman/shellcheck/wiki/SC1090
      # shellcheck source=/dev/null
      source "${MODULE_FILE}"
      if [[ ${THREAD_PRIO} -eq 1 ]] ; then
        SORTED_MODULES=( "${MODULE_FILE}" "${SORTED_MODULES[@]}" )
      else
        SORTED_MODULES=( "${SORTED_MODULES[@]}" "${MODULE_FILE}" )
      fi
    fi
  done
  MODULES=( "${SORTED_MODULES[@]}" )
}

# $1: module group letter [P, S, L, F, Q]
# $2: 0=single thread 1=multithread
# $3: HTML=1 - generate html file
run_modules()
{
  MODULE_GROUP="${1:-}"
  printf -v THREADING_SET '%d\n' "${2}" 2>/dev/null
  THREADING_MOD_GROUP="${THREADING_SET}"

  local SELECT_PRE_MODULES_COUNT=0

  for SELECT_NUM in "${SELECT_MODULES[@]}" ; do
    if [[ "${SELECT_NUM}" =~ ^["${MODULE_GROUP,,}","${MODULE_GROUP^^}"]{1} ]]; then
      (( SELECT_PRE_MODULES_COUNT+=1 ))
    fi
  done

  if [[ "${#SELECT_MODULES[@]}" -eq 0 ]] || [[ "${SELECT_PRE_MODULES_COUNT}" -eq 0 ]]; then
    local MODULES=()
    local MODULES_LOCAL=()
    local MODULES_EMBA=()

    mapfile -t MODULES_EMBA < <(find "${MOD_DIR}" -name "${MODULE_GROUP^^}""*_*.sh" | sort -V 2> /dev/null)
    if [[ -d "${MOD_DIR_LOCAL}" ]]; then
      mapfile -t MODULES_LOCAL < <(find "${MOD_DIR_LOCAL}" -name "${MODULE_GROUP^^}""*.sh" 2>/dev/null | sort -V 2> /dev/null)
    fi
    MODULES=( "${MODULES_EMBA[@]}" "${MODULES_LOCAL[@]}" )
    export MODULES_EXPORTED+=("${MODULES[@]}")
    if [[ ${THREADING_SET} -eq 1 && "${MODULE_GROUP^^}" != "P" ]] ; then
      sort_modules
    fi
    for MODULE_FILE in "${MODULES[@]}" ; do
      # check if "${MODULE_NAME}" is in blacklist from config directory and skip it
      MODULE_NAME=$(basename -s .sh "${MODULE_FILE}")
      if [[ " ${MODULE_BLACKLIST[*]} " =~  ${MODULE_NAME}  ]]; then
        print_output "[*] $(print_date) - ${MODULE_NAME} not executed - blacklist triggered " "main"
        continue
      fi
      if [[ "${SKIP_PRE_CHECKERS}" == 1 ]] && [[ "${MODULE_GROUP}" == "P" ]]; then
        print_output "[*] $(print_date) - ${MODULE_NAME} not executed - skip pre-checkers is set " "main"
        continue
      fi
      local MOD_FIN=0
      if ( file "${MODULE_FILE}" | grep -q "shell script" ) && ! [[ "${MODULE_FILE}" =~ \ |\' ]] ; then
        if [[ "${MODULE_GROUP^^}" == "P" ]] || [[ "${MODULE_GROUP^^}" == "D" ]]; then
          # we are able to enable/disable threading on module basis in the the pre-checker modules with the header:
          # export PRE_THREAD_ENA=1/0
          # shellcheck source=/dev/null
          source "${MODULE_FILE}"
          if [[ "${PRE_THREAD_ENA}" -eq 0 ]] ; then
            THREADING_SET=0
          fi
        fi
        MODULE_BN=$(basename "${MODULE_FILE}")
        MODULE_MAIN=${MODULE_BN%.*}
        # module_start_log "${MODULE_MAIN}"
        if [[ "${RESTART}" -eq 1 ]]; then
          if [[ $(grep -i -c "${MODULE_MAIN} finished" "${LOG_DIR}"/"${MAIN_LOG_FILE}") -gt 0 ]]; then
            if [[ "${MODULE_MAIN}" == "P99_"* ]] || [[ "${MODULE_MAIN}" == "L1"* ]]; then
              print_output "[*] $(print_date) - Module ${ORANGE}${MODULE_MAIN}${NC} already finished but essential - rerun it" "main"
              MOD_FIN=0
            else
              print_output "[*] $(print_date) - Module ${ORANGE}${MODULE_MAIN}${NC} already finished ... skipping" "main"
              MOD_FIN=1
              if [[ ${HTML} -eq 1 ]] ; then
                # we need to build the web reporter links for skipping modules
                mapfile -t LOG_FILES < <(find "${LOG_DIR}" -maxdepth 1 -type f -iname "${MODULE_MAIN}*.txt" | sort)
                for LOG_FILE_ in "${LOG_FILES[@]}"; do
                  if grep -q "nothing reported" "${LOG_FILE_}"; then
                    continue
                  fi
                  MODULE_NAME_=$(basename -s .txt "${LOG_FILE_}")
                  MODUL_NAME="$( strip_color_tags "$(grep -a -E -B 1 '[=]{65}' "${LOG_FILE_}" | head -n 1 )" | cut -d" " -f2- )"
                  HTML_FILE="${MODULE_NAME_}.html"
                  add_link_to_index "${HTML_FILE}" "${MODUL_NAME}"
                done
              fi
            fi
          fi
        fi
        if [[ "${MOD_FIN}" -eq 0 ]]; then
          if [[ ${THREADING_SET} -eq 1 ]]; then
            "${MODULE_MAIN}" &
            MOD_PID="$!"
            store_kill_pids "${MOD_PID}"
            WAIT_PIDS+=( "${MOD_PID}" )
            max_pids_protection "${MAX_MODS}" "${WAIT_PIDS[@]}"
          else
            "${MODULE_MAIN}"
          fi
        fi
        reset_module_count
      fi
      if [[ "${MODULE_GROUP^^}" == "P" ]]; then
        THREADING_SET="${THREADING_MOD_GROUP}"
      fi
    done
  else
    # in full emulation mode we need to ensure that module s24 is always running
    if [[ "${MODULE_GROUP}" == "S" ]] && [[ "${FULL_EMULATION}" -eq 1 ]] && [[ ! "${SELECT_MODULES[*]}" =~ [sS]24 ]]; then
      print_output "[*] Automatically enable module S24 for system emulation mode"
      SELECT_MODULES+=("S24")
    fi

    for SELECT_NUM in "${SELECT_MODULES[@]}" ; do
      local MOD_FIN=0
      if [[ "${SELECT_NUM}" =~ ^["${MODULE_GROUP,,}","${MODULE_GROUP^^}"]{1}[0-9]+ ]]; then
        local MODULE=""
        MODULE=$(find "${MOD_DIR}" -name "${MODULE_GROUP^^}""${SELECT_NUM:1}""_*.sh" | sort -V 2> /dev/null)
        # we need the whole module name including path in our array for later checks on it
        export MODULES_EXPORTED+=("${MODULE}")
        if ( file "${MODULE}" | grep -q "shell script" ) && ! [[ "${MODULE}" =~ \ |\' ]] ; then
          MODULE_BN=$(basename "${MODULE}")
          MODULE_MAIN=${MODULE_BN%.*}
          # module_start_log "${MODULE_MAIN}"
          if [[ "${RESTART}" -eq 1 ]]; then
            if [[ $(grep -i -c "${MODULE_MAIN} finished" "${LOG_DIR}"/"${MAIN_LOG_FILE}") -gt 0 ]]; then
              if [[ "${MODULE_MAIN}" == "P99_"* ]] || [[ "${MODULE_MAIN}" == "L1"* ]]; then
                print_output "[*] $(print_date) - Module ${ORANGE}${MODULE_MAIN}${NC} already finished but essential - rerun it" "main"
                MOD_FIN=0
              else
                print_output "[*] $(print_date) - Module ${ORANGE}${MODULE_MAIN}${NC} already finished ... skipping" "main"
                MOD_FIN=1
                if [[ ${HTML} -eq 1 ]] ; then
                  # we need to build the web reporter links for skipping modules
                  mapfile -t LOG_FILES < <(find "${LOG_DIR}" -maxdepth 1 -type f -iname "${MODULE_MAIN}*.txt" | sort)
                  for LOG_FILE_ in "${LOG_FILES[@]}"; do
                    if grep -q "nothing reported" "${LOG_FILE_}"; then
                      continue
                    fi
                    MODULE_NAME_=$(basename -s .txt "${LOG_FILE_}")
                    MODUL_NAME="$( strip_color_tags "$(grep -a -E -B 1 '[=]{65}' "${LOG_FILE_}" | head -n 1 )" | cut -d" " -f2- )"
                    HTML_FILE="${MODULE_NAME_}.html"
                    add_link_to_index "${HTML_FILE}" "${MODUL_NAME}"
                  done
                fi
              fi
            fi
          fi
          if [[ "${MOD_FIN}" -eq 0 ]]; then
            if [[ ${THREADING_SET} -eq 1 ]]; then
              "${MODULE_MAIN}" &
              MOD_PID="$!"
              store_kill_pids "${MOD_PID}"
              WAIT_PIDS+=( "${MOD_PID}" )
              max_pids_protection "${MAX_MODS}" "${WAIT_PIDS[@]}"
            else
              "${MODULE_MAIN}"
            fi
          fi
          reset_module_count
        fi
      elif [[ "${SELECT_NUM}" =~ ^["${MODULE_GROUP,,}","${MODULE_GROUP^^}"]{1} ]]; then
        local MODULES=()
        local MODULES_LOCAL=()
        local MODULES_EMBA=()
        mapfile -t MODULES_EMBA < <(find "${MOD_DIR}" -name "${MODULE_GROUP^^}""*_*.sh" | sort -V 2> /dev/null)
        if [[ -d "${MOD_DIR_LOCAL}" ]]; then
          mapfile -t MODULES_LOCAL < <(find "${MOD_DIR_LOCAL}" -name "${MODULE_GROUP^^}""*.sh" 2>/dev/null | sort -V 2> /dev/null)
        fi
        MODULES=( "${MODULES_EMBA[@]}" "${MODULES_LOCAL[@]}" )

        [[ ${THREADING_SET} -eq 1 ]] && sort_modules

        for MODULE_FILE in "${MODULES[@]}" ; do
          # check if "${MODULE_NAME}" is in blacklist from config directory and skip it
          MODULE_NAME=$(basename -s .sh "${MODULE_FILE}")
          if [[ " ${MODULE_BLACKLIST[*]} " =~  ${MODULE_NAME}  ]]; then
            print_output "[*] $(print_date) - ${MODULE_NAME} not executed - blacklist triggered " "main"
            continue
          fi
          local MOD_FIN=0
          if ( file "${MODULE_FILE}" | grep -q "shell script" ) && ! [[ "${MODULE_FILE}" =~ \ |\' ]] ; then
            if [[ "${MODULE_GROUP^^}" == "P" ]] || [[ "${MODULE_GROUP^^}" == "D" ]]; then
              # we are able to enable/disable threading on module basis in the the pre-checker modules with the header:
              # export PRE_THREAD_ENA=1/0
              # shellcheck source=/dev/null
              source "${MODULE_FILE}"
              if [[ "${PRE_THREAD_ENA}" -eq 0 ]] ; then
                THREADING_SET=0
              fi
            fi

            MODULE_BN=$(basename "${MODULE_FILE}")
            MODULE_MAIN=${MODULE_BN%.*}
            # module_start_log "${MODULE_MAIN}"
            if [[ "${RESTART}" -eq 1 ]]; then
              if [[ $(grep -i -c "${MODULE_MAIN} finished" "${LOG_DIR}"/"${MAIN_LOG_FILE}") -gt 0 ]]; then
                if [[ "${MODULE_MAIN}" == "P99_"* ]] || [[ "${MODULE_MAIN}" == "L1"* ]]; then
                  print_output "[*] $(print_date) - Module ${ORANGE}${MODULE_MAIN}${NC} already finished but essential - rerun it" "main"
                  MOD_FIN=0
                else
                  print_output "[*] $(print_date) - Module ${ORANGE}${MODULE_MAIN}${NC} already finished ... skipping" "main"
                  MOD_FIN=1
                  if [[ ${HTML} -eq 1 ]] ; then
                    # we need to build the web reporter links for skipping modules
                    mapfile -t LOG_FILES < <(find "${LOG_DIR}" -maxdepth 1 -type f -iname "${MODULE_MAIN}*.txt" | sort)
                    for LOG_FILE_ in "${LOG_FILES[@]}"; do
                      if grep -q "nothing reported" "${LOG_FILE_}"; then
                        continue
                      fi
                      MODULE_NAME_=$(basename -s .txt "${LOG_FILE_}")
                      MODUL_NAME="$( strip_color_tags "$(grep -a -E -B 1 '[=]{65}' "${LOG_FILE_}" | head -n 1 )" | cut -d" " -f2- )"
                      HTML_FILE="${MODULE_NAME_}.html"
                      add_link_to_index "${HTML_FILE}" "${MODUL_NAME}"
                    done
                  fi
                fi
              fi
            fi
            if [[ "${MOD_FIN}" -eq 0 ]]; then
              if [[ ${THREADING_SET} -eq 1 ]]; then
                "${MODULE_MAIN}" &
                MOD_PID="$!"
                store_kill_pids "${MOD_PID}"
                WAIT_PIDS+=( "${MOD_PID}" )
                max_pids_protection "${MAX_MODS}" "${WAIT_PIDS[@]}"
              else
                "${MODULE_MAIN}"
              fi
            fi
            reset_module_count
          fi
          if [[ "${MODULE_GROUP^^}" == "P" ]]; then
            THREADING_SET="${THREADING_MOD_GROUP}"
          fi
        done
      fi
    done
  fi
}

main() {
  # set 命令主要用来设置 shell
  # set -a 将所有后续定义的变量自动导出为环境变量
  set -a
  # trap 允许您捕获信号并在信号发生时执行代码
  # trap cleaner INT 设置一个陷阱，当接收到 INT 信号时（通常是用户按下 Ctrl+C），执行 cleaner 函数
  trap cleaner INT

  # ${0}: 当前脚本的名称
  # $(dirname "${0}"): 当前脚本所在的目录路径
  INVOCATION_PATH="$(dirname "${0}")"

  # $: 特殊变量，表示当前进程的 PID
  # export EMBA_PID="$$": 将当前进程的 PID 存储在名为 EMBA_PID 的环境变量中，并导出这个变量，使其在子进程中也可用。
  export EMBA_PID="$$"

  # loads default values for EMBA
  export HELP_DIR="${INVOCATION_PATH}""/helpers"
  import_helper
  # helpers_emba_defaults.sh 中定义
  # 预定义 emba 运行过程中所涉及的环境变量默认值
  set_defaults

  # helpers_emba_print.sh 中定义
  print_ln "no_log"
  import_module
  # helpers_emba_print.sh 中定义
  welcome  # Print EMBA welcome message

  # $#: 特殊变量，脚本命令行参数的个数
  if [[ $# -eq 0 ]]; then
    # helpers_emba_print.sh 中定义
    print_output "\\n""${ORANGE}""In order to be able to use EMBA, you have to specify at least a firmware (-f)." "no_log"
    print_output "If you don't set a log directory (-l), then ./logs will be used.""${NC}" "no_log"
    print_help
    exit 1
  fi

  export EMBA_COMMAND
  # 将脚本目录下的emba脚本文件绑定到变量 EMBA_COMMAND
  EMBA_COMMAND="$(dirname "${0}")""/emba ""$*"

  # helpers_emba_parameter_parser.sh 文件中定义
  # 解析传递给脚本的命令行参数
  emba_parameter_parsing "$@"

  print_ln "no_log"

  write_notification "EMBA starting"

  # WSL support - currently experimental!
  if [[ ${IN_DOCKER} -eq 0 ]]; then
    if grep -q -i wsl /proc/version; then
      print_bar "no_log"
      print_output "[*] $(print_date) - INFO: System running in WSL environment!" "no_log"
      print_output "[*] $(print_date) - INFO: WSL is currently experimental." "no_log"
      print_output "[*] $(print_date) - INFO: Please report issues to https://github.com/e-m-b-a/emba/issues." "no_log"
      print_bar "no_log"
      export WSL=1
    fi
  fi

  # print it only once per EMBA run - not again from started container
  [[ ${IN_DOCKER} -eq 0 ]] && banner_printer

  if [[ ${IN_DOCKER} -eq 1 ]] ; then
    # set external path new for docker
    export EXT_DIR="/external"
  fi

  # activate the virtual environment - we should have it in external which fits also the docker environment
  # shellcheck source=/dev/null
  if [[ -f "${EXT_DIR}/emba_venv/bin/activate" ]]; then
    print_output "[*] $(print_date) - Enable python virtual environment ${ORANGE}${EXT_DIR}/emba_venv${NC}" "no_log"
    source "${EXT_DIR}/emba_venv/bin/activate"
  fi

  # EMBA should be started with "sudo -E" to access the proxy settings from the user
  export PROXY_SETTINGS=""
  PROXY_SETTINGS="$(env | grep "http_proxy=http" | cut -d = -f2 | sort -u | head -1)"
  if [[ -n "${PROXY_SETTINGS}" ]]; then
    # 2nd try with the original user:
    PROXY_SETTINGS="$(sudo -E -u "${SUDO_USER:-${USER}}" env | grep -E "http_proxy=http" | cut -d = -f2 | sort -u | head -1)"
  else
    if [[ -f "${LOG_DIR}"/orig_user.log ]]; then
      if grep -q "PROXY: http" "${LOG_DIR}"/orig_user.log; then
        PROXY_SETTINGS="$(grep "PROXY: http" "${LOG_DIR}"/orig_user.log | awk '{print $2}')"
      fi
    fi
  fi

  # Check all dependencies of EMBA
  dependency_check

  if [[ "${ONLY_DEP}" -eq 0 ]]; then
    if [[ "${UPDATE}" -eq 1 ]]; then
      write_notification "EMBA starts with update"
      emba_updater
      exit 0
    fi

    if [[ ${USE_DOCKER} -eq 0 && ${IN_DOCKER} -eq 0 ]]; then
      print_bar "no_log"
      print_output "[!] $(print_date) - WARNING: EMBA running in developer mode!" "no_log"
      write_notification "WARNING: EMBA running in developer mode"
      print_bar "no_log"
    fi

    enable_strict_mode "${STRICT_MODE}" 1

    # profile handling
    if [[ -n "${PROFILE:-}" ]]; then
      if [[ -f "${PROFILE}" ]]; then
        print_bar "no_log"
        if [[ ${IN_DOCKER} -ne 1 ]] ; then
          print_output "[*] $(print_date) - Loading EMBA scan profile with the following settings:" "no_log"
        else
          print_output "[*] $(print_date) - Loading EMBA scan profile." "no_log"
        fi
        # all profile output and settings are done by the profile file located in ./scan-profiles/
        # shellcheck source=/dev/null
        source "${PROFILE}"
        print_output "[*] $(print_date) - Profile ${PROFILE} loaded." "no_log"
        print_bar "no_log"
      else
        print_output "[!] $(print_date) - Profile ${PROFILE} not found." "no_log"
        exit 1
      fi
    fi

    if [[ "${ONLY_DEP}" -eq 0 ]]; then
      # check provided paths for validity
      check_path_valid "${FIRMWARE_PATH}"
      check_path_valid "${KERNEL_CONFIG}"
      check_path_valid "${LOG_DIR}"
    fi

    # restart file gets generated during startup if old log dir is found:
    if [[ ${IN_DOCKER} -eq 1 && "${CONTAINER_NUMBER}" -eq 1 ]] || [[ "${USE_DOCKER}" -eq 0 && ${IN_DOCKER} -eq 0 ]]; then
      if [[ -f "${TMP_DIR}"/restart_emba ]]; then
        print_output "[!] $(print_date) - Found restart file and backup_vars file ... trying to restart EMBA scan" "no_log"
        export RESTART=1
        rm "${TMP_DIR}"/restart_emba
        # shellcheck source=/dev/null
        source "${LOG_DIR}""/backup_vars.log"
      fi
    fi

    # check if LOG_DIR exists and prompt to terminal to delete its content (Y/n)
    [[ ${IN_DOCKER} -eq 0 ]] && log_folder

    # create log directory, if not exists and needed subdirectories
    # do not create a log dir for dep check
    export MAIN_LOG="${LOG_DIR}""/""${MAIN_LOG_FILE}"
    [[ "${ONLY_DEP}" -eq 0 ]] && create_log_dir

    # kernel downloader runs on the host and waits for an identified kernel version. Afterwards
    # it tries to download the kernel sources for further analysis
    if [[ ${IN_DOCKER} -eq 0 ]]; then
      kernel_downloader &
      K_DOWN_PID="$!"
      store_kill_pids "${K_DOWN_PID}"
      print_output "[*] $(print_date) - Started kernel downloader thread with PID ${ORANGE}${K_DOWN_PID}${NC}" "no_log"
    fi

    if [[ ${IN_DOCKER} -eq 0 ]]; then
      echo "${LOG_DIR}" > "${TMP_DIR}"/orig_logdir
    fi

    if [[ "${IN_DOCKER}" -eq 0 ]]; then
      print_notification &
      NOTIFICATION_PID="$!"
      store_kill_pids "${NOTIFICATION_PID}"
      disown "${NOTIFICATION_PID}" 2> /dev/null || true
      print_output "[*] $(print_date) - Original user: ${ORANGE}${SUDO_USER:-${USER}}${NC}" "no_log"
      print_output "[*] $(print_date) - Notification process started with PID ${ORANGE}${NOTIFICATION_PID}${NC}" "no_log"
      PROXY="$(sudo -E -u "${SUDO_USER:-${USER}}" env | grep -E "http(s)_proxy" | cut -d = -f2 || true)"
      echo "${SUDO_USER:-${USER}}" > "${LOG_DIR}"/orig_user.log
      {
        echo "UID: $(id -u "${SUDO_USER:-${USER}}")"
        echo "GID: $(id -g "${SUDO_USER:-${USER}}")"
        echo "PROXY: ${PROXY}"
      } >> "${LOG_DIR}"/orig_user.log
    fi

    if [[ "${IN_DOCKER}" -eq 0 ]]; then
      print_running_modules &
      RUN_MOD_PID="$!"
      store_kill_pids "${RUN_MOD_PID}"
      echo "${RUN_MOD_PID}" > "${LOG_DIR}"/print_running_modules.pid
      disown "${RUN_MOD_PID}" 2> /dev/null || true
    fi

    # Print additional information about the firmware (-Y, -X, -Z, -N)
    print_firmware_info "${FW_VENDOR}" "${FW_VERSION}" "${FW_DEVICE}" "${FW_NOTES}"
    if [[ "${KERNEL}" -ne 1 ]] && [[ "${CONTAINER_EXTRACT}" -ne 1 ]] && [[ "${ONLY_DEP}" -eq 0 ]]; then
      check_init_size
    fi

    # Now we have the firmware and log path, lets set some additional paths
    FIRMWARE_PATH="$(abs_path "${FIRMWARE_PATH}")"

    # Check firmware type (file/directory)
    # copy the firmware outside of the docker and not a second time within the docker
    if [[ -d "${FIRMWARE_PATH}" ]] ; then
      PRE_CHECK=1
      print_output "[*] $(print_date) - Firmware directory detected." "no_log"
      print_output "[*] $(print_date) - EMBA starts with testing the environment." "no_log"
      if [[ ${IN_DOCKER} -eq 0 ]] ; then
        # in docker environment the firmware is already available
        print_output "    The provided firmware will be copied to ${ORANGE}""${FIRMWARE_PATH_CP}""/""$(basename "${FIRMWARE_PATH}")""${NC}" "no_log"
        cp -R "${FIRMWARE_PATH}" "${FIRMWARE_PATH_CP}""/""$(basename "${FIRMWARE_PATH}")"
        FIRMWARE_PATH="${FIRMWARE_PATH_CP}""/""$(basename "${FIRMWARE_PATH}")"
        export OUTPUT_DIR="${FIRMWARE_PATH_CP}"
      else
        # need to set it as fallback:
        export OUTPUT_DIR="${FIRMWARE_PATH}"
      fi
    elif [[ "${CONTAINER_EXTRACT}" -eq 1 ]]; then
      PRE_CHECK=1
      print_output "[*] $(print_date) - Firmware analysis of docker image starting." "no_log"
      print_output "    EMBA starts with extracting the docker image ${ORANGE}${CONTAINER_ID}${NC}." "no_log"
      export FIRMWARE_PATH="${LOG_DIR}"/firmware/firmware_docker_extracted.tar
      export OUTPUT_DIR="${FIRMWARE_PATH}"
      export FIRMWARE=1
    elif [[ -f "${FIRMWARE_PATH}" ]] && [[ -z "${FIRMWARE_PATH1}" ]]; then
      PRE_CHECK=1
      if [[ -n "${KERNEL_CONFIG}" && "${KERNEL}" -eq 1 ]]; then
        print_output "[*] $(print_date) - Kernel configuration file detected." "no_log"
      else
        print_output "[*] $(print_date) - Firmware binary detected." "no_log"
      fi
      print_output "    EMBA starts with the pre-testing phase." "no_log"
      export OUTPUT_DIR="${FIRMWARE_PATH}"
    elif [[ -f "${FIRMWARE_PATH}" ]] && [[ -f "${FIRMWARE_PATH1}" ]]; then
      DIFF_MODE=1
      print_output "[*] $(print_date) - Multiple firmware binarie detected." "no_log"
      print_output "    EMBA starts in firmware diff mode." "no_log"
    else
      print_output "[!] $(print_date) - Invalid firmware file" "no_log"
      print_help
      exit 1
    fi

    # calculate the maximum modules are running in parallel
    if [[ ${THREADED} -eq 1 ]] && [[ "${MAX_MODS}" -eq 0 ]]; then
      # the maximum modules in parallel
      # rule of thumb - per core half a module, minimum 2 modules
      MAX_MODS="$(( "$(grep -c ^processor /proc/cpuinfo)" /2 +1))"

      # if we have only one core we run two modules in parallel
      if [[ "${MAX_MODS}" -lt 2 ]]; then
        MAX_MODS=2
      fi
      export MAX_MODS
    fi

    # calculate the maximum threads per module
    if [[ ${THREADED} -eq 1 ]] && [[ "${MAX_MOD_THREADS}" -eq 0 ]]; then
      # the maximum threads per modules - if this value does not match adjust it via
      # local MAX_MOD_THREADS=123 in module area
      export MAX_MOD_THREADS="$(( 2* "$(grep -c ^processor /proc/cpuinfo)" ))"
    fi

    # setup non threaded mode:
    if [[ ${THREADED} -eq 0 ]]; then
      export MAX_MODS=1
      export MAX_MOD_THREADS=1
    fi
    if [[ "${MAX_MODS}" -eq 1 ]] || [[ "${MAX_MOD_THREADS}" -eq 1 ]]; then
      print_ln "no_log"
      print_output "[!] WARNING: EMBA is running with ${ORANGE}${MAX_MODS}${MAGENTA} modules in parallel and ${ORANGE}${MAX_MOD_THREADS}${MAGENTA} threads per module." "no_log"
      print_output "[!] This scan could take a very long time ..." "no_log"
    else
      print_output "$(indent "EMBA is running with ${ORANGE}${MAX_MODS}${NC} modules in parallel and ${ORANGE}${MAX_MOD_THREADS}${NC} threads per module.")" "no_log"
    fi

    # Change log output to color for web report and prepare report
    if [[ ${HTML} -eq 1 ]] ; then
      if [[ ${FORMAT_LOG} -eq 0 ]] ; then
        FORMAT_LOG=1
        print_output "[*] $(print_date) - Activate colored log for webreport" "no_log"
      fi
      print_output "[*] $(print_date) - Prepare webreport" "no_log"
      prepare_report
    fi

    if [[ ${LOG_GREP} -eq 1 ]] ; then
      # Create grep-able log file
      create_grep_log
      write_grep_log "sudo ""${EMBA_COMMAND}" "COMMAND"
    fi

    if [[ "${KERNEL}" -ne 1 ]] && [[ ${FIRMWARE} -eq 1 ]]; then
      # Exclude paths from testing and set EXCL_FIND for find command (prune paths dynamicially)
      set_exclude
    fi

    #######################################################################################
    # Kernel configuration check
    #######################################################################################
    if [[ "${KERNEL}" -eq 1 ]]; then
      if [[ ${IN_DOCKER} -eq 1 ]] && [[ -f "${LOG_DIR}"/kernel_config ]]; then
        export KERNEL_CONFIG="${LOG_DIR}"/kernel_config
      fi

      if ! [[ -f "${KERNEL_CONFIG}" ]] ; then
        print_output "[-] $(print_date) - Invalid kernel configuration file: ${ORANGE}${KERNEL_CONFIG}${NC}" "no_log"
        exit 1
      else
        if [[ ${IN_DOCKER} -eq 0 ]] ; then
          # we copy the kernel config file from outside the container into our log directory
          # further modules are using LOG_DIR/kernel_config for accessing the kernel config
          if [[ -d "${LOG_DIR}" ]] ; then
            cp "${KERNEL_CONFIG}" "${LOG_DIR}"/kernel_config
          else
            print_output "[!] $(print_date) - Missing log directory" "no_log"
            exit 1
          fi
        fi
      fi
    fi

    # disk space monitor not fully working -> removed for now
    # Todo: check it and fix it
    # disk_space_monitor "${EMBA_PID}" &
    # local TMP_PID="$!"
    # store_kill_pids "${TMP_PID}"
    # disown "${TMP_PID}" 2> /dev/null || true

    # if $CONTAINER_EXTRACT is set we extract the docker container with id $CONTAINER_ID outside of the
    # EMBA container into log directory
    # we do this outside of the EMBA container - otherwise we will not reach the docker environment
    if [[ "${CONTAINER_EXTRACT}" -eq 1 && "${IN_DOCKER}" -eq 0 ]] ; then
      docker_container_extractor "${CONTAINER_ID}"
    fi
  fi

  #######################################################################################
  # Docker
  #######################################################################################
  if [[ ${USE_DOCKER} -eq 1 ]] ; then
    if ! [[ ${EUID} -eq 0 ]] ; then
      if ! groups | grep -qw docker; then
        print_output "[!] $(print_date) - Using EMBA with docker-compose requires root permissions" "no_log"
        print_output "$(indent "Run EMBA with root permissions or add your user to docker group")" "no_log"
        print_output "$(indent "e.g., sudo usermod -aG docker [non-root user]")" "no_log"
        exit 1
      fi
    fi

    OPTIND=1
    ARGUMENTS=()
    while getopts a:A:BcC:d:De:Ef:Fghijk:l:m:N:o:p:P:QrsStT:UX:yY:WzZ: OPT ; do
      case ${OPT} in
        D|f|i|l|o)
          ;;
        *)
          if [[ -v OPTARG[@] ]] ; then
            ARGUMENTS=( "${ARGUMENTS[@]}" "-${OPT}" "${OPTARG[@]}" )
          else
            ARGUMENTS=( "${ARGUMENTS[@]}" "-${OPT}" )
          fi
          ;;
      esac
    done

    if [[ "${IN_DOCKER}" -eq 0 ]] && [[ "${SILENT}" -eq 1 ]]; then
      initial_status_bar &
      # Trap the window resize signal (handle window resize events).
      trap 'initial_status_bar' WINCH
    fi

    print_output "[*] $(print_date) - EMBA sets up the docker environment.\\n" "no_log"

    # try it 10 times before exit
    local CNT_DOCK=0
    for CNT_DOCK in {1..10}; do
      if ! docker images | grep -qE "embeddedanalyzer/emba[[:space:]]"; then
        sleep 1
      else
        break
      fi
      if [[ "${CNT_DOCK}" -ge 10 ]]; then
        print_output "[-] $(print_date) - EMBA docker environment not ready!" "no_log"
        exit 1
      fi
    done

    print_output "[*] $(print_date) - EMBA initializes docker container.\\n" "no_log"

    if [[ "${ONLY_DEP}" -eq 0 ]]; then
      # store some details that we do not have in the docker container:
      echo "${FIRMWARE_PATH}" >> "${TMP_DIR}"/fw_name.log
      if [[ "${DIFF_MODE}" -gt 0 ]]; then
        echo "${FIRMWARE_PATH1}" >> "${TMP_DIR}"/fw_name.log
      fi
      echo "${LOG_DIR}" >> "${TMP_DIR}"/emba_log_dir.log
      echo "${EMBA_COMMAND}" >> "${TMP_DIR}"/emba_command.log
    fi

    write_notification "EMBA starting docker container"

    [[ "${STRICT_MODE}" -eq 1 ]] && set +e

    disable_strict_mode "${STRICT_MODE}" 0
    if [[ "${ONLY_DEP}" -gt 0 ]]; then
      # check dependencies mode:
      EMBA="${INVOCATION_PATH}" FIRMWARE="${FIRMWARE_PATH}" LOG="/tmp" "${DOCKER_COMPOSE[@]}" run --rm emba -c './emba -l /logs -f /firmware -i "$@"' _ "${ARGUMENTS[@]}"
      D_RETURN=$?
      EMBA="${INVOCATION_PATH}" FIRMWARE="${FIRMWARE_PATH}" LOG="/tmp" "${DOCKER_COMPOSE[@]}" run --rm emba_quest -c './emba -l /logs -f /firmware -i "$@"' _ "${ARGUMENTS[@]}"
      if [[ $? -ne ${D_RETURN} ]]; then
        D_RETURN=1
      fi
    elif [[ "${DIFF_MODE}" -gt 0 ]]; then
      FIRMWARE_PATH1="$(abs_path "${FIRMWARE_PATH1}")"
      # firmware diff mode - needs two firmware files:
      EMBA="${INVOCATION_PATH}" FIRMWARE="${FIRMWARE_PATH}" LOG="${LOG_DIR}" "${DOCKER_COMPOSE[@]}" run -v "${FIRMWARE_PATH1}":/firmware2 --rm emba -c './emba -l /logs -f /firmware -o /firmware2 -i "$@"' _ "${ARGUMENTS[@]}"
      D_RETURN=$?
    else
      print_ln "no_log"
      welcome
      # default EMBA analysis mode:
      local QUEST_CONTAINER_=""
      QUEST_CONTAINER_="$(EMBA="${INVOCATION_PATH}" FIRMWARE="${FIRMWARE_PATH}" LOG="${LOG_DIR}" "${DOCKER_COMPOSE[@]}" run --detach --rm emba_quest -c './emba -l /logs -f /firmware -i "$@"' _ "${ARGUMENTS[@]}")"
      export QUEST_CONTAINER="${QUEST_CONTAINER_}"
      print_output "[+] $(print_date) - Quest container ${QUEST_CONTAINER_} started and detached.\\n" "no_log"

      # EMBA startup:
      if [[ "${SILENT}" -eq 0 ]]; then
        # EMBA container starts in the foreground and we can see all the logs
        EMBA="${INVOCATION_PATH}" FIRMWARE="${FIRMWARE_PATH}" LOG="${LOG_DIR}" "${DOCKER_COMPOSE[@]}" run --rm emba -c './emba -l /logs -f /firmware -i "$@"' _ "${ARGUMENTS[@]}"
        D_RETURN=$?
      else
        # EMBA container starts in the background
        print_output "[*] $(print_date) - EMBA main container starting and detaching.\\n" "no_log"
        local MAIN_CONTAINER_=""
        MAIN_CONTAINER_="$(EMBA="${INVOCATION_PATH}" FIRMWARE="${FIRMWARE_PATH}" LOG="${LOG_DIR}" "${DOCKER_COMPOSE[@]}" run --detach --rm emba -c './emba -l /logs -f /firmware -i "$@"' _ "${ARGUMENTS[@]}")"
        export MAIN_CONTAINER="${MAIN_CONTAINER_}"

        print_output "[+] $(print_date) - EMBA main container ${MAIN_CONTAINER_} started and detached." "no_log"
        print_ln "no_log"
        # the following write_log is used as the status bar shows the main emba.log and with a print_output we get double output
        write_log "[*] $(print_date) - EMBA main container ${MAIN_CONTAINER_} monitoring through ${ORANGE}docker logs ${MAIN_CONTAINER_} -f${NC}." "${LOG_DIR}/emba.log"
        if [[ "$( docker container inspect -f '{{.State.Status}}' "${QUEST_CONTAINER_}" )" == "running" ]]; then
          write_log "[*] $(print_date) - EMBA quest container ${QUEST_CONTAINER_} monitoring through ${ORANGE}docker logs ${QUEST_CONTAINER_} -f${NC}." "${LOG_DIR}/emba.log"
        fi

        while [[ "$( docker container inspect -f '{{.State.Status}}' "${MAIN_CONTAINER_}" )" == "running" ]]; do
          sleep 1
        done
        remove_status_bar
        # reset
        printf "\x1Bc"

        if [[ -f "${LOG_DIR}"/f50_base_aggregator.txt ]]; then
          cat "${LOG_DIR}"/f50_base_aggregator.txt
        fi
        D_RETURN=0
      fi
    fi
    enable_strict_mode "${STRICT_MODE}" 0

    if [[ "${D_RETURN}" -eq 0 ]] ; then
      if [[ "${ONLY_DEP}" -eq 0 ]] ; then
        print_output "[*] $(print_date) - EMBA finished analysis in default mode (docker container).\\n" "no_log"
        write_notification "EMBA finished analysis in default mode"
        print_output "[*] $(print_date) - Firmware tested: ${ORANGE}${FIRMWARE_PATH}${NC}" "no_log"
        print_output "[*] $(print_date) - Log directory: ${ORANGE}${LOG_DIR}${NC}" "no_log"
        if [[ -v HTML_PATH ]] && [[ -f "${HTML_PATH}"/index.html ]]; then
          print_output "[*] $(print_date) - Access the web-report with ${ORANGE}firefox $(abs_path "${HTML_PATH}/index.html")${NC}" "main"
        fi
        cleaner 0
        print_output "[!] $(print_date) - Test ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "main"
      else
        # we do not need the log dir from dependency checker
        [[ -d "${LOG_DIR}" ]] && rm -rf "${LOG_DIR}"
        print_output "[!] $(print_date) - Test ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "no_log"
      fi
      exit 0
    else
      print_output "[-] $(print_date) - Test ended on ""$(print_date)"" and EMBA failed in docker mode!" "main"
      cleaner 0
      write_notification "EMBA failed analysis in default mode"
      exit 1
    fi
  fi

  #######################################################################################
  # Quests (Q-modules)
  #######################################################################################

  if [[ -v CONTAINER_NUMBER ]] && [[ "${DIFF_MODE}" -ne 1 ]]; then
    if [[ "${CONTAINER_NUMBER}" -eq 2 ]] ;  then
      while ! grep -q "Pre-checking phase started" "${LOG_DIR}"/"${MAIN_LOG_FILE}"; do
        sleep 1
      done
      run_modules "Q" "${THREADED}" "0"
      [[ "${THREADED}" -eq 1 ]] && wait_for_pid "${WAIT_PIDS[@]}"
      print_output "[*] $(print_date) - Quest container finished" "main"
      exit 0
    elif [[ "${USE_DOCKER}" -eq 0 && "${IN_DOCKER}" -eq 0 ]] ;  then
      # currently we do not support the Quest containers in dev mode
      while ! grep -q "Pre-checking phase started" "${LOG_DIR}"/"${MAIN_LOG_FILE}"; do
        sleep 1
      done
      # dev-mode
      run_modules "Q" "${THREADED}" "0" &
      export Q_MOD_PID="$!"
    elif [[ "${CONTAINER_NUMBER}" -ne 1 ]]; then
      docker logs "${QUEST_CONTAINER}" --follow | grep "ok" && print_output "[*] Quest container ${QUEST_CONTAINER_} failed the dependancy check" "main"
    fi
  fi

  #######################################################################################
  # Pre-Check (P-modules)
  #######################################################################################
  if [[ "${PRE_CHECK}" -eq 1 ]] && [[ "${DIFF_MODE}" -ne 1 ]]; then

    print_ln "no_log"
    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] $(print_date) - Pre-checking phase started on ""$(print_date)""\\n""$(indent "${NC}""Firmware binary path: ""${FIRMWARE_PATH}")" "main"
    else
      print_output "[!] $(print_date) - Pre-checking phase started on ""$(print_date)""\\n""$(indent "${NC}""Firmware binary path: ""${FIRMWARE_PATH}")" "no_log"
    fi
    write_notification "Pre-checking phase started"

    # 'main' functions of imported modules
    # in the pre-check phase we execute all modules with P[Number]_Name.sh

    run_modules "P" "${THREADED}" "0"

    # if we running threaded we ware going to wait for the slow guys here
    [[ ${THREADED} -eq 1 ]] && wait_for_pid "${WAIT_PIDS[@]}"

    print_ln "no_log"

    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] $(print_date) - Pre-checking phase ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "main"
    else
      print_output "[!] $(print_date) - Pre-checking phase ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "no_log"
    fi
    write_notification "Pre-checking phase finished"

    # useful prints for debugging:
    # print_output "[!] Firmware value: ${FIRMWARE}"
    # print_output "[!] Firmware path: ${FIRMWARE}_PATH"
    # print_output "[!] Output dir: $OUTPUT_DIR"
    # print_output "[!] LINUX_PATH_COUNTER: $LINUX_PATH_COUNTER"
    # print_output "[!] LINUX_PATH_ARRAY: ${#ROOT_PATH[@]}"
  fi

  #######################################################################################
  # Diff mode (D-modules)
  #######################################################################################
  if [[ "${DIFF_MODE}" -eq 1 ]] ; then

    print_ln "no_log"
    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] $(print_date) - Diff mode started on ""$(print_date)" "main"
      print_output "$(indent "${NC}""1st Firmware binary path: ""${FIRMWARE_PATH}")" "main"
      print_output "$(indent "${NC}""2nd Firmware binary path: ""${FIRMWARE_PATH1}")" "main"
    else
      print_output "[!] $(print_date) - Diff mode started on ""$(print_date)"
      print_output "$(indent "${NC}""1st Firmware binary path: ""${FIRMWARE_PATH}")" "no_log"
      print_output "$(indent "${NC}""2nd Firmware binary path: ""${FIRMWARE_PATH1}")" "no_log"
    fi
    write_notification "Diff mode started"

    run_modules "D" "${THREADED}" "0"

    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] $(print_date) - Diff mode ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "main"
    else
      print_output "[!] $(print_date) - Diff mode ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "no_log"
    fi
    write_notification "Diff mode finished"

    TESTING_DONE=1

  fi

  #######################################################################################
  # Firmware-Check (S modules)
  #######################################################################################
  WAIT_PIDS=()
  if [[ ${FIRMWARE} -eq 1 ]] && [[ "${DIFF_MODE}" -ne 1 ]]; then
    print_output "\n=================================================================\n" "no_log"

    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] $(print_date) - Testing phase started on ""$(print_date)""\\n""$(indent "${NC}""Firmware path: ""${FIRMWARE_PATH}")" "main"
    else
      print_output "[!] $(print_date) - Testing phase started on ""$(print_date)""\\n""$(indent "${NC}""Firmware path: ""${FIRMWARE_PATH}")" "no_log"
    fi
    write_notification "Testing phase finished"
    write_grep_log "$(print_date)" "TIMESTAMP"

    run_modules "S" "${THREADED}" "${HTML}"

    [[ ${THREADED} -eq 1 ]] && wait_for_pid "${WAIT_PIDS[@]}"

    print_ln "no_log"

    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] $(print_date) - Testing phase ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "main"
    else
      print_output "[!] $(print_date) - Testing phase ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "no_log"
    fi
    write_notification "Testing phase ended"

    TESTING_DONE=1
  fi

  #######################################################################################
  # Live Emulation - Check (L-modules)
  #######################################################################################
  if [[ "${FULL_EMULATION}" -eq 1 ]] && [[ "${DIFF_MODE}" -ne 1 ]]; then
    print_output "\n=================================================================\n" "no_log"
    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] $(print_date) - System emulation phase started on ""$(print_date)""\\n""$(indent "${NC}""Firmware path: ""${FIRMWARE_PATH}")" "main"
    else
      print_output "[!] $(print_date) - System emulation phase started on ""$(print_date)""\\n""$(indent "${NC}""Firmware path: ""${FIRMWARE_PATH}")" "no_log"
    fi
    write_notification "System emulation phase started"

    write_grep_log "$(print_date)" "TIMESTAMP"
    # these modules are not threaded!
    run_modules "L" "0" "${HTML}"

    print_ln "no_log"
    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] $(print_date) - System emulation phase ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "main"
    else
      print_output "[!] $(print_date) - System emulation ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "no_log"
    fi
    write_notification "System emulation phase ended"
  fi

  #######################################################################################
  # Reporting (F-modules)
  #######################################################################################
  if [[ -d "${LOG_DIR}" ]]; then
    print_output "[!] $(print_date) - Reporting phase started on ""$(print_date)""\\n" "main"
  else
    print_output "[!] $(print_date) - Reporting phase started on ""$(print_date)""\\n" "no_log"
  fi
  write_notification "Reporting phase started"

  run_modules "F" "0" "${HTML}"

  [[ ${DISABLE_STATUS_BAR} -eq 0 ]] && remove_status_bar

  write_notification "Reporting phase ended"

  if [[ "${USE_DOCKER}" -eq 0 && "${THREADED}" -eq 1 && "${IN_DOCKER}" -eq 0 ]] && [[ -n "${Q_MOD_PID}" ]];  then
    wait_for_pid "${Q_MOD_PID}"
  fi

  if [[ "${TESTING_DONE}" -eq 1 ]]; then
    if [[ "${FINAL_FW_RM}" -eq 1 && -d "${LOG_DIR}"/firmware ]]; then
      print_output "[*] $(print_date) - Removing temp firmware directory\\n" "no_log"
      rm -r "${LOG_DIR}"/firmware 2>/dev/null
    fi
    if [[ "${FINAL_FW_RM}" -eq 1 && -d "${LOG_DIR}"/p61_unblob_eval/unblob_extracted ]]; then
      print_output "[*] $(print_date) - Removing unblob firmware directory\\n" "no_log"
      rm -r "${LOG_DIR}"/p61_unblob_eval/unblob_extracted 2>/dev/null
    fi
    print_ln "no_log"
    if [[ -d "${LOG_DIR}" ]]; then
      print_output "[!] $(print_date) - Test ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "main"
      write_notification "EMBA finished analysis"
      rm -r "${TMP_DIR}" 2>/dev/null || true
    else
      print_output "[!] $(print_date) - Test ended on ""$(print_date)"" and took about ""$(show_runtime)"" \\n" "no_log"
    fi
    write_grep_log "$(print_date)" "TIMESTAMP"
    write_grep_log "$(date -d@"${SECONDS}" -u +%d:%H:%M:%S)" "DURATION"
  else
    print_output "[!] $(print_date) - No extracted firmware found" "no_log"
    print_output "$(indent "Try using binwalk or something else to extract the firmware")"
    exit 1
  fi

  [[ "${HTML}" -eq 1 ]] && update_index

  if [[ -f "${HTML_PATH}"/index.html ]] && [[ "${IN_DOCKER}" -eq 0 ]]; then
    print_output "[*] $(print_date) - Web report created HTML report in ${ORANGE}${LOG_DIR}/html-report${NC}\\n" "main"
    print_output "[*] $(print_date) - Open the web-report with${ORANGE} firefox $(abs_path "${HTML_PATH}/index.html")${NC}\\n" "main"
  fi

  # deactivate the python virtual env
  [[ -v VIRTUAL_ENV ]] && deactivate

  # we need to change the permissions of the LOG_DIR to the orig. user from the host
  [[ "${IN_DOCKER}" -eq 1 ]] && restore_permissions
  cleaner 0
  exit 0
}

main "$@"
